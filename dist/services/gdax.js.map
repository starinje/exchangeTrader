{"version":3,"sources":["../../src/services/gdax.js"],"names":["GdaxService","options","requestPrivate","endpoint","params","logger","info","requestPublic","requestOptions","method","uri","baseUrl","body","session","reject","getOrderBook","orderBook","bids","map","bidLevel","price","amount","asks","askLevel","timeStamp","executeTrade","tradeDetails","action","quantity","rate","console","log","newOrder","availableBalances","orderStatus","orderId","sandbox","defaults","json","headers"],"mappings":"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","file":"gdax.js","sourcesContent":["import rp from 'request-promise'\nimport crypto from 'crypto';\nimport shortid from 'shortid';\nimport Promise from 'bluebird'\n\n\n// function createRequestConfig({ key, secret, payload }){\n\n//   const encodedPayload = (new Buffer(JSON.stringify(payload)))\n//     .toString(`base64`);\n\n//   const signature = crypto\n//     .createHmac(`sha384`, secret)\n//     .update(encodedPayload)\n//     .digest(`hex`);\n\n//   return {\n//       'X-GEMINI-APIKEY': key,\n//       'X-GEMINI-PAYLOAD': encodedPayload,\n//       'X-GEMINI-SIGNATURE': signature,\n//   };\n// }\n\n\nexport default class GdaxService {\n\n    constructor(options){\n        this.options = options || {}\n        this.logger = this.options.logger\n        this.baseUrl = this.options.sandbox ? `https://api-public.sandbox.gdax.com` : `https://api.gdax.com`\n        this.session = rp.defaults({\n            json: true,\n            headers: {\n                'User-Agent': 'Request-Promise'\n            }\n        })\n    }\n\n    requestPrivate = async(endpoint, params = {}) => {\n        try{\n            // //code here to send private request\n            // if (!this.options.key || !this.options.secret) {\n            //     throw new Error(\n            //         `API key and secret key required to use authenticated methods`,\n            //     );\n            // }\n\n            // const requestUrl = `${this.baseUrl}${endpoint}`\n\n            // const payload = {\n            //     nonce: Date.now(),\n            //     request: `/v1${endpoint}`,\n            //     ...params,\n            // };\n\n\n            // const config = createRequestConfig({\n            //     payload,\n            //     key: this.options.key,\n            //     secret: this.options.secret,\n            // });\n\n            // const requestOptions = {\n            //     method: 'POST',\n            //     uri: requestUrl,\n            //     headers: config\n            // }\n\n            // return await this.session(requestOptions)\n        } catch(err) {\n            this.logger.info(`error: ${err}`)\n            return \n        }\n    }\n\n    requestPublic = async (endpoint, params = {}) => {\n        try {\n            const requestOptions = {\n                method: 'GET',\n                uri: `${this.baseUrl}${endpoint}`,\n                body: {\n                    ...params\n                }\n            }\n\n            return await this.session(requestOptions) \n        } catch(err) {\n            return Promise.reject(err)\n        } \n    }\n\n    getOrderBook = async () => {\n        try{\n            let orderBook = await this.requestPublic(`/products/ETH-USD/book?level=2`, {})\n\n             const bids = orderBook.bids.map((bidLevel) => {\n                return {\n                    price: bidLevel[0],\n                    amount: bidLevel[1]\n                }\n            })\n\n            const asks = orderBook.asks.map((askLevel) => {\n                return {\n                    price: askLevel[0],\n                    amount: askLevel[1]\n                }\n            })\n\n            // reformat order book into standard format\n            return {\n                asks: asks,\n                bids: bids,\n                timeStamp: 'timestamp'\n            }\n        } catch(err){\n            this.logger.info(err)\n        }\n\n    }\n\n    executeTrade = async (tradeDetails) => {\n        this.logger.info(`placing ${tradeDetails.action} trade on Gemini for ${tradeDetails.quantity} ethereum at $${tradeDetails.rate}/eth`)\n\n        console.log('code to execute gdax trade...')\n\n        // TODO: pick up code here....\n        \n        // let orderParams = { \n        //     client_order_id: \"20150102-4738721\", \n        //     symbol: 'ethusd',       \n        //     amount: tradeDetails.quantity,        \n        //     price: tradeDetails.rate,\n        //     side: tradeDetails.action,\n        //     type: 'exchange limit'\n        // }\n\n        // let orderResults = await this.newOrder(orderParams)\n\n        // let tradeCompleted = false\n        // let tradeCompletedDetails\n\n        // while(!tradeCompleted){\n        //     await Promise.delay(1000)\n        //     let tradeStatus = await this.orderStatus(orderResults.order_id)\n        //     if(tradeStatus.executed_amount == tradeStatus.original_amount){\n        //         tradeCompleted = true\n        //         tradeCompletedDetails = tradeStatus\n        //     }\n        // }\n\n        // return tradeCompletedDetails\n    }\n\n    newOrder = async (params = {}) => {\n        // return await this.requestPrivate(`/order/new`, {\n        //     client_order_id: shortid(),\n        //     type: `exchange limit`,\n        //     ...params,\n        // })\n    }\n\n    availableBalances = async () => {\n        // return this.requestPrivate(`/balances`)\n    }\n\n    orderStatus = (orderId) => {\n        // return this.requestPrivate(`/order/status`, { order_id: orderId })\n    }\n}"]}