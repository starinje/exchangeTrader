{"version":3,"sources":["../../src/services/gdax.js"],"names":["GdaxService","options","getOrderBook","resolve","reject","publicClient","getProductOrderBook","err","response","data","orderBook","bids","length","asks","Error","map","bidLevel","price","amount","askLevel","reformattedOrderBook","timeStamp","executeTrade","positionChange","tradeDetails","gdax","counterPrice","gemini","rate","rateDelta","Math","abs","tradeCompleted","tradeProfitable","finalOrderResults","tradeQuantity","quantity","action","lowestSellPriceLevel","find","ask","parseFloat","console","log","highestBuyPriceLevel","toFixed","toString","logger","info","orderParams","productId","size","process","exit","newOrder","orderResults","JSON","parse","body","stringify","hasOwnProperty","status","delay","timeStart","utc","Date","timeExpired","now","timeSinceTradePlaced","duration","diff","orderStatus","id","tradeStatus","filled_size","asMinutes","orderFillTime","cancelOrders","tradeSummary","fee","fill_fees","params","reformattedParams","product_id","post_only","postOnly","authedClient","results","cancelAllOrders","availableBalances","getAccounts","orderId","getOrder","baseUrl","sandbox","PublicClient","AuthenticatedClient","key","secret","passphrase"],"mappings":"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","file":"gdax.js","sourcesContent":["import rp from 'request-promise'\nimport crypto from 'crypto';\nimport shortid from 'shortid';\nimport Promise from 'bluebird'\nimport Gdax from 'gdax'\nimport moment from 'moment'\n\nexport default class GdaxService {\n    constructor(options){\n        this.options = options || {}\n        this.logger = this.options.logger\n        this.baseUrl = this.options.sandbox ? `https://api-public.sandbox.gdax.com` : `https://api.gdax.com`\n        this.publicClient = new Gdax.PublicClient('ETH-USD', this.baseUrl);\n        this.authedClient = new Gdax.AuthenticatedClient(\n            this.options.key, this.options.secret, this.options.passphrase, this.baseUrl);\n        }\n\n    getOrderBook = async () => {\n        try{\n            return new Promise((resolve, reject) => {\n                this.publicClient.getProductOrderBook({'level': 2}, (err, response, data) => {\n\n                    if(err){\n                        return reject(err)\n                    }\n\n                    let orderBook = {...data}\n\n                    if(orderBook.bids.length < 1 || orderBook.asks.length < 1){\n                        return reject(new Error('order book is corrupted'))\n                    }\n                \n                    const bids = orderBook.bids.map((bidLevel) => {\n                        return {\n                            price: bidLevel[0],\n                            amount: bidLevel[1]\n                        }\n                    })\n\n                    const asks = orderBook.asks.map((askLevel) => {\n                        return {\n                            price: askLevel[0],\n                            amount: askLevel[1]\n                        }\n                    })\n\n                    let reformattedOrderBook = {\n                        asks: asks,\n                        bids: bids,\n                        timeStamp: 'timestamp'\n                    }\n\n                    return resolve(reformattedOrderBook)\n                })\n            })\n        } catch(err){\n            return Promise.reject(`gdax getOrderBook |> ${err}`)\n        }\n      \n    }\n\n    executeTrade = async (positionChange) => {\n        try{\n\n            const tradeDetails = positionChange.gdax\n            const counterPrice = positionChange.gemini.rate\n            const rateDelta = Math.abs(positionChange.gdax.rate - positionChange.gemini.rate)\n\n            let tradeCompleted = false\n            let tradeProfitable = true\n\n            let finalOrderResults\n            let price\n            let tradeQuantity = tradeDetails.quantity\n\n            while(!tradeCompleted && tradeProfitable){\n\n                let orderBook = await this.getOrderBook()\n                \n                switch(tradeDetails.action){\n                case 'buy':\n                    // let lowestSellPrice = parseFloat(orderBook.asks[0].price)\n                    // price = lowestSellPrice - .01\n                    // let highestBuyPrice = parseFloat(orderBook.bids[0].price)\n                    // price = highestBuyPrice \n\n                    let lowestSellPriceLevel = orderBook.asks.find((ask) => {\n                        return parseFloat(ask.amount) >= tradeQuantity\n                    })\n\n                    price = parseFloat(lowestSellPriceLevel.price)\n                    console.log(`gdax buy price is: ${price}`)\n\n                    if(price >= counterPrice){ //-(rateDelta/2)\n                        tradeProfitable = false\n                        continue\n                    }\n                    break\n                case 'sell':\n                   // let highestBuyPrice = parseFloat(orderBook.bids[0].price)\n                    // price = highestBuyPrice + .01\n                    // let lowestSellPrice = parseFloat(orderBook.asks[0].price)\n                    // price = lowestSellPrice\n\n                    let highestBuyPriceLevel = orderBook.bids.find((ask) => {\n                        return parseFloat(ask.amount) >= tradeQuantity\n                    })\n\n                    price = parseFloat(highestBuyPriceLevel.price)\n                    console.log(`gdax sell price is: ${price}`)\n\n                    if(price <= counterPrice){ //+(rateDelta/2)\n                        tradeProfitable = false\n                        continue\n                    }\n                    break\n                }\n\n                price = price.toFixed(2).toString()\n\n                this.logger.info(`placing ${tradeDetails.action} trade on Gdax for ${tradeDetails.quantity} ethereum at $${price}/eth`)\n\n                let orderParams = { \n                    productId: 'ETH-USD',       \n                    size: tradeQuantity,        \n                    price: price,\n                    action: tradeDetails.action,\n                    //postOnly: true\n                }\n\n                if(parseFloat(orderParams.price) < 250){\n                    this.logger.info(`failed gdax price sanity check. price: ${orderParams.price} `)\n                    process.exit()\n                }\n\n                let orderResults = await this.newOrder(orderParams)\n                orderResults = JSON.parse(orderResults.body)\n                console.log(`gdax order results: ${JSON.stringify(orderResults)}`)\n\n                //TODO - need to check for order sucess - not for order failure....\n\n                if(!(orderResults.hasOwnProperty('status')) || !(orderResults.status == 'pending')){\n                    this.logger.info('gdax order could not be submitted')\n                    this.logger.info(orderResults)\n                    continue\n                }\n\n                await Promise.delay(1000)\n\n                let timeStart = moment.utc(new Date())\n                let timeExpired = false\n\n                this.logger.info(`gdax order entered - going into check status loop...`)\n                while(!timeExpired && !tradeCompleted){\n                    await Promise.delay(1000)\n                    let now = moment.utc(new Date())\n                    let timeSinceTradePlaced = moment.duration(now.diff(timeStart))\n\n                    let tradeStatus = await this.orderStatus(orderResults.id)\n                    if(tradeStatus.filled_size == tradeStatus.size){\n                        tradeCompleted = true\n                        finalOrderResults = orderResults\n                        continue\n                    } else {\n                        tradeQuantity = parseFloat(tradeStatus.size) - parseFloat(tradeStatus.filled_size)\n                    }\n\n                    if(timeSinceTradePlaced.asMinutes() > this.options.orderFillTime){\n                        this.logger.info(`time has expired trying to ${tradeDetails.action} ${tradeDetails.quantity} ethereum on gdax at ${price}/eth, canceling order`)\n                        await this.cancelOrders()\n                        timeExpired = true\n                    }\n                }\n            }\n\n            let tradeSummary\n\n            if(tradeCompleted){\n\n                let tradeSummary = {\n                    fee: parseFloat(finalOrderResults.fill_fees),\n                    amount: parseFloat(finalOrderResults.size),\n                    price: parseFloat(finalOrderResults.price),\n                }\n\n                return {...tradeSummary, action: tradeDetails.action}\n            } else if(!tradeProfitable){\n                this.logger.info(`${tradeDetails.action} on gdax for ${tradeDetails.quantity} ethereum at ${price}/eth was unsuccesful - order book no longer profitable`)\n                process.exit()\n            }\n        } catch(err){\n            return Promise.reject(`gdax executeTrade |> ${err}`)\n        }\n    }\n\n    // executeTradeOld = async (tradeDetails, orderBook) => {\n    //     try{\n    //         //this.logger.info(`placing ${tradeDetails.action} trade on Gdax for ${tradeDetails.quantity} ethereum at $${tradeDetails.rate}/eth`)\n\n    //         // here we have the desired buy/sell level\n    //         // need to place a maker-or-cancel order\n    //         // switch on action (buy/sell)\n    //         // generate array of available priceLevels \n    //         // if trying to sell, place maker-only sell in the spread lower than the current \n    //         //logic here to sweep across the price range attempting to place maker only orders\n    //         //if it cant then just place market order\n\n    //         orderBook = await this.getOrderBook()\n    //         this.logger.info('retrieving latest order book from gdax')\n    //         let price\n\n    //         switch(tradeDetails.action){\n    //             case 'buy':\n    //                 price = orderBook.bids[1].price\n    //                 break\n    //             case 'sell':\n    //                 price = orderBook.asks[1].price\n    //                 break\n    //         }\n\n    //         this.logger.info(`placing ${tradeDetails.action} trade on Gdax for ${tradeDetails.quantity} ethereum at $${price}/eth`)\n        \n    //         let orderParams = { \n    //             productId: 'ETH-USD',       \n    //             size: tradeDetails.quantity,        \n    //             price: price,\n    //             action: tradeDetails.action,\n    //             postOnly: true\n    //         }\n\n    //         let orderResults = await this.newOrder(orderParams)\n    //         orderResults = JSON.parse(orderResults.body)\n\n    //         let tradeCompleted = false\n    //         let tradeCompletedDetails\n\n    //         while(!tradeCompleted){\n    //             let tradeStatus = await this.orderStatus(orderResults.id)\n    //             if(tradeStatus.status == 'done'){\n    //                 tradeCompleted = true\n    //                 tradeCompletedDetails = tradeStatus\n    //             }\n    //             await Promise.delay(1000)\n    //         }\n\n    //         let tradeSummary = {\n    //             fee: parseFloat(tradeCompletedDetails.fill_fees),\n    //             amount: parseFloat(tradeCompletedDetails.size),\n    //             price: parseFloat(tradeCompletedDetails.price),\n    //             action: tradeDetails.action\n    //         }\n\n    //         return tradeSummary\n    //     } catch(err){\n    //         return Promise.reject(`gdax executeTrade |> ${err}`)\n    //     } \n       \n    // }\n\n    // executeTradeOldest = async (tradeDetails, orderBook) => {\n    //     try{\n    //         this.logger.info(`placing ${tradeDetails.action} trade on Gdax for ${tradeDetails.quantity} ethereum at $${tradeDetails.rate}/eth`)\n\n    //         //should pass in profitable price range\n    //         //logic here to sweep across the price range attempting to place maker only orders\n    //         //if it cant then just place market order\n        \n    //         let orderParams = { \n    //             productId: 'ETH-USD',       \n    //             size: tradeDetails.quantity,        \n    //             price: tradeDetails.rate,\n    //             action: tradeDetails.action\n    //         }\n\n    //         let orderResults = await this.newOrder(orderParams)\n    //         orderResults = JSON.parse(orderResults.body)\n\n    //         let tradeCompleted = false\n    //         let tradeCompletedDetails\n\n    //         while(!tradeCompleted){\n    //             let tradeStatus = await this.orderStatus(orderResults.id)\n    //             if(tradeStatus.status == 'done'){\n    //                 tradeCompleted = true\n    //                 tradeCompletedDetails = tradeStatus\n    //             }\n    //             await Promise.delay(1000)\n    //         }\n\n    //         let tradeSummary = {\n    //             fee: parseFloat(tradeCompletedDetails.fill_fees),\n    //             amount: parseFloat(tradeCompletedDetails.size),\n    //             price: parseFloat(tradeCompletedDetails.price),\n    //             action: tradeDetails.action\n    //         }\n\n    //         return tradeSummary\n\n    //     } catch(err){\n    //         return Promise.reject(`gdax executeTrade |> ${err}`)\n    //     } \n       \n    // }\n\n    newOrder = async (params = {}) => {\n        try {\n            return new Promise((resolve, reject) => {\n\n                const reformattedParams = {\n                    price: params.price,\n                    size: params.size,\n                    product_id: params.productId,\n                    post_only: params.postOnly,\n                }\n\n                this.authedClient[params.action](reformattedParams, (err, results, data) => {\n                    return resolve(results)\n                })\n            })\n        } catch(err){\n            return Promise.reject(`gdax newOrder Error: ${err}`)\n            \n        }\n    }\n\n    cancelOrders = async () => {\n        try {\n            return new Promise((resolve, reject) => {\n                this.authedClient.cancelAllOrders( (err, results, data) => {\n                    return resolve(results)\n                })\n            })\n        } catch(err){\n            return Promise.reject(`gdax cancelOrders Error: ${err}`)\n            \n        }\n    }\n\n    \n    availableBalances = async () => {\n        try {\n            return new Promise((resolve, reject) => {\n                this.authedClient.getAccounts((err, results, data) => {\n                    return resolve(data)\n                })\n            })\n           \n        } catch(err){\n            return Promise.reject(`gdax accounts |> ${err}`)\n        }\n    }\n\n    orderStatus = (orderId) => {\n        try {  \n           return new Promise((resolve, reject) => {\n               this.authedClient.getOrder(orderId, (err, results, data) => {\n                   return resolve(data)\n               });\n            })\n        } catch(err){\n            return Promise.reject(`gdax orderStatus |> ${err}`)\n        }\n    }\n}"]}