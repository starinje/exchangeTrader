{"version":3,"sources":["../../src/services/gdax.js"],"names":["GdaxService","options","getOrderBook","resolve","reject","publicClient","getProductOrderBook","err","response","data","orderBook","bids","length","asks","Error","map","bidLevel","price","amount","askLevel","reformattedOrderBook","timeStamp","executeTrade","tradeDetails","logger","info","action","quantity","orderParams","productId","size","postOnly","newOrder","orderResults","JSON","parse","body","tradeCompleted","tradeCompletedDetails","orderStatus","id","tradeStatus","status","delay","tradeSummary","fee","parseFloat","fill_fees","params","reformattedParams","product_id","post_only","authedClient","results","availableBalances","getAccounts","orderId","getOrder","baseUrl","sandbox","PublicClient","AuthenticatedClient","key","secret","passphrase"],"mappings":"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","file":"gdax.js","sourcesContent":["import rp from 'request-promise'\nimport crypto from 'crypto';\nimport shortid from 'shortid';\nimport Promise from 'bluebird'\nimport Gdax from 'gdax'\n\nexport default class GdaxService {\n    constructor(options){\n        this.options = options || {}\n        this.logger = this.options.logger\n        this.baseUrl = this.options.sandbox ? `https://api-public.sandbox.gdax.com` : `https://api.gdax.com`\n        this.publicClient = new Gdax.PublicClient('ETH-USD', this.baseUrl);\n        this.authedClient = new Gdax.AuthenticatedClient(\n            this.options.key, this.options.secret, this.options.passphrase, this.baseUrl);\n        }\n\n    getOrderBook = async () => {\n        try{\n            return new Promise((resolve, reject) => {\n                this.publicClient.getProductOrderBook({'level': 2}, (err, response, data) => {\n\n                    if(err){\n                        return reject(err)\n                    }\n\n                    let orderBook = {...data}\n\n                    if(orderBook.bids.length < 1 || orderBook.asks.length < 1){\n                        return reject(new Error('order book is corrupted'))\n                    }\n                \n                    const bids = orderBook.bids.map((bidLevel) => {\n                        return {\n                            price: bidLevel[0],\n                            amount: bidLevel[1]\n                        }\n                    })\n\n                    const asks = orderBook.asks.map((askLevel) => {\n                        return {\n                            price: askLevel[0],\n                            amount: askLevel[1]\n                        }\n                    })\n\n                    let reformattedOrderBook = {\n                        asks: asks,\n                        bids: bids,\n                        timeStamp: 'timestamp'\n                    }\n\n                    return resolve(reformattedOrderBook)\n                })\n            })\n        } catch(err){\n            return Promise.reject(`gdax getOrderBook |> ${err}`)\n        }\n      \n    }\n\n    executeTrade = async (tradeDetails, orderBook) => {\n        try{\n            //this.logger.info(`placing ${tradeDetails.action} trade on Gdax for ${tradeDetails.quantity} ethereum at $${tradeDetails.rate}/eth`)\n\n            // here we have the desired buy/sell level\n            // need to place a maker-or-cancel order\n            // switch on action (buy/sell)\n            // generate array of available priceLevels \n            // if trying to sell, place maker-only sell in the spread lower than the current \n            //logic here to sweep across the price range attempting to place maker only orders\n            //if it cant then just place market order\n\n            orderBook = await this.getOrderBook()\n            this.logger.info('retrieving latest order book from gdax')\n            let price\n\n            switch(tradeDetails.action){\n                case 'buy':\n                    price = orderBook.bids[1].price\n                    break\n                case 'sell':\n                    price = orderBook.asks[1].price\n                    break\n            }\n\n            this.logger.info(`placing ${tradeDetails.action} trade on Gdax for ${tradeDetails.quantity} ethereum at $${price}/eth`)\n        \n            let orderParams = { \n                productId: 'ETH-USD',       \n                size: tradeDetails.quantity,        \n                price: price,\n                action: tradeDetails.action,\n                postOnly: true\n            }\n\n            let orderResults = await this.newOrder(orderParams)\n            orderResults = JSON.parse(orderResults.body)\n\n            let tradeCompleted = false\n            let tradeCompletedDetails\n\n            while(!tradeCompleted){\n                let tradeStatus = await this.orderStatus(orderResults.id)\n                if(tradeStatus.status == 'done'){\n                    tradeCompleted = true\n                    tradeCompletedDetails = tradeStatus\n                }\n                await Promise.delay(1000)\n            }\n\n            let tradeSummary = {\n                fee: parseFloat(tradeCompletedDetails.fill_fees),\n                amount: parseFloat(tradeCompletedDetails.size),\n                price: parseFloat(tradeCompletedDetails.price),\n                action: tradeDetails.action\n            }\n\n            return tradeSummary\n\n            return \n        } catch(err){\n            return Promise.reject(`gdax executeTrade |> ${err}`)\n        } \n       \n    }\n\n    // executeTradeOld = async (tradeDetails, orderBook) => {\n    //     try{\n    //         this.logger.info(`placing ${tradeDetails.action} trade on Gdax for ${tradeDetails.quantity} ethereum at $${tradeDetails.rate}/eth`)\n\n    //         //should pass in profitable price range\n    //         //logic here to sweep across the price range attempting to place maker only orders\n    //         //if it cant then just place market order\n        \n    //         let orderParams = { \n    //             productId: 'ETH-USD',       \n    //             size: tradeDetails.quantity,        \n    //             price: tradeDetails.rate,\n    //             action: tradeDetails.action\n    //         }\n\n    //         let orderResults = await this.newOrder(orderParams)\n    //         orderResults = JSON.parse(orderResults.body)\n\n    //         let tradeCompleted = false\n    //         let tradeCompletedDetails\n\n    //         while(!tradeCompleted){\n    //             let tradeStatus = await this.orderStatus(orderResults.id)\n    //             if(tradeStatus.status == 'done'){\n    //                 tradeCompleted = true\n    //                 tradeCompletedDetails = tradeStatus\n    //             }\n    //             await Promise.delay(1000)\n    //         }\n\n    //         let tradeSummary = {\n    //             fee: parseFloat(tradeCompletedDetails.fill_fees),\n    //             amount: parseFloat(tradeCompletedDetails.size),\n    //             price: parseFloat(tradeCompletedDetails.price),\n    //             action: tradeDetails.action\n    //         }\n\n    //         return tradeSummary\n\n    //     } catch(err){\n    //         return Promise.reject(`gdax executeTrade |> ${err}`)\n    //     } \n       \n    // }\n\n    newOrder = async (params = {}) => {\n        try {\n            return new Promise((resolve, reject) => {\n\n                const reformattedParams = {\n                    price: params.price,\n                    size: params.size,\n                    product_id: params.productId,\n                    post_only: params.postOnly,\n                }\n\n                this.authedClient[params.action](reformattedParams, (err, results, data) => {\n                    return resolve(results)\n                })\n            })\n        } catch(err){\n            return Promise.reject(`gdax newOrder Error: ${err}`)\n            \n        }\n    }\n\n    \n    availableBalances = async () => {\n        try {\n            return new Promise((resolve, reject) => {\n                this.authedClient.getAccounts((err, results, data) => {\n                    return resolve(data)\n                })\n            })\n           \n        } catch(err){\n            return Promise.reject(`gdax accounts |> ${err}`)\n        }\n    }\n\n    orderStatus = (orderId) => {\n        try {  \n           return new Promise((resolve, reject) => {\n               this.authedClient.getOrder(orderId, (err, results, data) => {\n                   return resolve(data)\n               });\n            })\n        } catch(err){\n            return Promise.reject(`gdax orderStatus |> ${err}`)\n        }\n    }\n}"]}