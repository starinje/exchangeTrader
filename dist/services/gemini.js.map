{"version":3,"sources":["../../src/services/gemini.js"],"names":["createRequestConfig","key","secret","payload","encodedPayload","Buffer","JSON","stringify","toString","signature","createHmac","update","digest","GeminiService","options","requestPrivate","endpoint","params","Error","requestUrl","baseUrl","nonce","Date","now","request","config","requestOptions","method","uri","headers","session","reject","requestPublic","body","getOrderBook","orderBook","timestamp","bids","map","bidLevel","price","amount","asks","askLevel","executeTradeOld","tradeDetails","logger","info","action","quantity","orderParams","client_order_id","symbol","rate","side","type","newOrder","orderResults","tradeCompleted","delay","orderStatus","order_id","tradeStatus","executed_amount","original_amount","orderHistory","tradeSummary","executeTrade","positionChange","gemini","counterPrice","gdax","rateDelta","Math","abs","tradeProfitable","finalOrderResults","tradeQuantity","lowestSellPriceLevel","find","ask","parseFloat","highestBuyPriceLevel","toFixed","process","exit","is_cancelled","timeStart","utc","timeExpired","timeSinceTradePlaced","duration","diff","asMinutes","orderFillTime","cancelOrders","availableBalances","orderId","err","trades","orderTrades","filter","trade","fee","numberOfTrades","forEach","fee_amount","averagePrice","subdomain","sandbox","defaults","json"],"mappings":"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","file":"gemini.js","sourcesContent":["import rp from 'request-promise'\nimport crypto from 'crypto';\nimport shortid from 'shortid';\nimport Promise from 'bluebird'\nimport moment from 'moment'\n\n\nfunction createRequestConfig({ key, secret, payload }){\n\n  const encodedPayload = (new Buffer(JSON.stringify(payload)))\n    .toString(`base64`);\n\n  const signature = crypto\n    .createHmac(`sha384`, secret)\n    .update(encodedPayload)\n    .digest(`hex`);\n\n  return {\n      'X-GEMINI-APIKEY': key,\n      'X-GEMINI-PAYLOAD': encodedPayload,\n      'X-GEMINI-SIGNATURE': signature,\n  };\n}\n\n\nexport default class GeminiService {\n\n    constructor(options){\n        this.options = options || {}\n        this.logger = this.options.logger\n        const subdomain = this.options.sandbox ? `api.sandbox` : `api`;\n        this.baseUrl = `https://${subdomain}.gemini.com/v1`;\n        this.session = rp.defaults({\n            json: true,\n            headers: {\n                'User-Agent': 'Request-Promise'\n            }\n        })\n    }\n\n    requestPrivate = async(endpoint, params = {}) => {\n        try{\n            if (!this.options.key || !this.options.secret) {\n                throw new Error(\n                    `API key and secret key required to use authenticated methods`,\n                );\n            }\n\n            const requestUrl = `${this.baseUrl}${endpoint}`\n\n            const payload = {\n                nonce: Date.now(),\n                request: `/v1${endpoint}`,\n                ...params,\n            };\n\n\n            const config = createRequestConfig({\n                payload,\n                key: this.options.key,\n                secret: this.options.secret,\n            });\n\n            const requestOptions = {\n                method: 'POST',\n                uri: requestUrl,\n                headers: config\n            }\n\n            return await this.session(requestOptions)\n        } catch(err) {\n            return Promise.reject(`gemini requestPrivate |> ${err}`)\n        }\n    }\n\n    requestPublic = async (endpoint, params = {}) => {\n        try {\n            const requestOptions = {\n                method: 'GET',\n                uri: `${this.baseUrl}${endpoint}`,\n                body: {\n                    ...params\n                }\n            }\n\n            return await this.session(requestOptions) \n        } catch(err) {\n            return Promise.reject(`gemini requestPublic |> ${err}`)\n        } \n    }\n\n    getOrderBook = async () => {\n        try{\n            let orderBook = await this.requestPublic(`/book/ethusd`, {})\n\n            let timestamp = orderBook.bids[0].timestamp\n\n            const bids = orderBook.bids.map((bidLevel) => {\n                return {\n                    price: bidLevel.price,\n                    amount: bidLevel.amount\n                }\n            })\n\n            const asks = orderBook.asks.map((askLevel) => {\n                return {\n                    price: askLevel.price,\n                    amount: askLevel.amount\n                }\n            })\n\n            return { asks, bids,timestamp}\n        } catch(err){\n            return Promise.reject(`gemini getOrderBook |> ${err}`)\n        }\n\n    }\n\n    executeTradeOld = async (tradeDetails, orderBook) => {\n        try{\n            orderBook = await this.getOrderBook()\n            this.logger.info('retrieving latest order book from gemini')\n            let price\n\n            switch(tradeDetails.action){\n                case 'buy':\n                    price = orderBook.bids[1].price\n                    break\n                case 'sell':\n                    price = orderBook.asks[1].price\n                    break\n            }\n\n            this.logger.info(`placing ${tradeDetails.action} trade on Gemini for ${tradeDetails.quantity} ethereum at $${price}/eth`)\n        \n            let orderParams = { \n                client_order_id: \"20150102-4738721\", \n                symbol: 'ethusd',       \n                amount: tradeDetails.quantity,        \n                price: tradeDetails.rate,\n                side: tradeDetails.action,\n                type: 'exchange limit',\n            }\n\n            let orderResults = await this.newOrder(orderParams)\n            \n            let tradeCompleted = false\n\n            while(!tradeCompleted){\n                await Promise.delay(1000)\n                let tradeStatus = await this.orderStatus(orderResults.order_id)\n                if(tradeStatus.executed_amount == tradeStatus.original_amount){\n                    tradeCompleted = true\n                }\n            }\n\n            let tradeSummary = await this.orderHistory(orderResults.order_id)\n\n            return {...tradeSummary, action: tradeDetails.action}\n\n        } catch(err){\n            return Promise.reject(`gemini executeTrade |> ${err}`)\n        }\n    }\n\n    executeTrade = async (positionChange) => {\n        try{\n\n            const tradeDetails = positionChange.gemini\n            const counterPrice = positionChange.gdax.rate\n            const rateDelta = Math.abs(positionChange.gdax.rate - positionChange.gemini.rate)\n\n            let tradeCompleted = false\n            let tradeProfitable = true\n\n            let finalOrderResults\n            let price\n            let tradeQuantity = tradeDetails.quantity\n\n            while(!tradeCompleted && tradeProfitable){\n                let orderBook = await this.getOrderBook()\n                \n                switch(tradeDetails.action){\n                case 'buy':\n                    // let lowestSellPrice = parseFloat(orderBook.asks[0].price)\n                    // price = lowestSellPrice - .01\n\n                    // let highestBuyPrice = parseFloat(orderBook.bids[0].price)\n                    // price = highestBuyPrice \n\n                    let lowestSellPriceLevel = orderBook.asks.find((ask) => {\n                        return parseFloat(ask.amount) >= tradeQuantity\n                    })\n\n                    price = parseFloat(lowestSellPriceLevel.price)\n\n                    if(price >= counterPrice){ //-(rateDelta/2)\n                        tradeProfitable = false\n                        continue\n                    }\n                    break\n                case 'sell':\n                    // let highestBuyPrice = parseFloat(orderBook.bids[0].price)\n                    // price = highestBuyPrice + .01\n\n                    // let lowestSellPrice = parseFloat(orderBook.asks[0].price)\n                    // price = lowestSellPrice\n\n                    let highestBuyPriceLevel = orderBook.bids.find((ask) => {\n                        return parseFloat(ask.amount) >= tradeQuantity\n                    })\n\n                    price = parseFloat(highestBuyPriceLevel.price)\n\n\n                    if(price <= counterPrice){ //+(rateDelta/2)\n                        tradeProfitable = false\n                        continue\n                    }\n                    break\n                }\n\n                price = price.toFixed(2).toString()\n\n                this.logger.info(`placing ${tradeDetails.action} trade on Gemini for ${tradeDetails.quantity} ethereum at $${price}/eth`)\n            \n                let orderParams = { \n                    client_order_id: \"20150102-4738721\", \n                    symbol: 'ethusd',       \n                    amount: tradeQuantity,        \n                    price: price,\n                    side: tradeDetails.action,\n                    type: 'exchange limit',\n                    //options: ['maker-or-cancel']\n                }\n\n                if(parseFloat(orderParams.price) < 250 || parseFloat(orderParams.price) > 400){\n                    this.logger.info(`failed gemini price sanity check. price: ${orderParams.price} `)\n                    process.exit()\n                }\n\n                let orderResults = await this.newOrder(orderParams)\n\n                if(orderResults.is_cancelled){\n                    this.logger.info('gemini order could not be submitted')\n                    this.logger.info(orderResults)\n                    continue\n                }\n\n                await Promise.delay(1000)\n\n                let timeStart = moment.utc(new Date())\n                let timeExpired = false\n\n                this.logger.info(`gemini order entered - going into check status loop...`)\n                while(!timeExpired && !tradeCompleted){\n                    await Promise.delay(1000)\n                    let now = moment.utc(new Date())\n                    let timeSinceTradePlaced = moment.duration(now.diff(timeStart))\n\n                    let tradeStatus = await this.orderStatus(orderResults.order_id)\n                    if(tradeStatus.executed_amount == tradeStatus.original_amount){\n                        tradeCompleted = true\n                        finalOrderResults = orderResults\n                        continue\n                    } else {\n                        tradeQuantity = parseFloat(tradeStatus.original_amount) - parseFloat(tradeStatus.executed_amount)\n                    }\n\n                    if(timeSinceTradePlaced.asMinutes() > this.options.orderFillTime){\n                        this.logger.info(`time has expired trying to ${tradeDetails.action} ${tradeDetails.quantity} ethereum on gemini at ${price}/eth, canceling order`)\n                        await this.cancelOrders()\n                        timeExpired = true\n                    }\n                }\n            }\n\n            let tradeSummary\n\n            if(tradeCompleted){\n                tradeSummary = await this.orderHistory(finalOrderResults.order_id)\n                return {...tradeSummary, action: tradeDetails.action}\n            } else if(!tradeProfitable){\n                this.logger.info(`${tradeDetails.action} on gemini for ${tradeDetails.quantity} ethereum at ${price}/eth was unsuccesful - order book no longer profitable`)\n                process.exit()\n            }\n        } catch(err){\n            return Promise.reject(`gemini executeTrade |> ${err}`)\n        }\n    }\n\n    newOrder = async (params = {}) => {\n        try {\n            return this.requestPrivate(`/order/new`, {\n                client_order_id: shortid(),\n                type: `exchange limit`,\n                ...params,\n            })\n        } catch(err){\n            return Promise.reject(`gemini newOrder |> ${err}`)\n        }\n        \n    }\n\n    cancelOrders = async (params = {}) => {\n        try {\n            return this.requestPrivate(`/order/cancel/all`)\n        } catch(err){\n            return Promise.reject(`gemini cancelOrders |> ${err}`)\n        }\n        \n    }\n\n    availableBalances = async () => {\n        try {\n            return this.requestPrivate(`/balances`)\n        } catch(err){\n            return Promise.reject(`gemini availableBalances |> ${err}`)\n        }\n    }\n\n    orderStatus = (orderId) => {\n        try {\n            return this.requestPrivate(`/order/status`, { order_id: orderId })\n        } catch(err){\n            return Promise.reject(`gemini orderStatus |> ${err}`)\n        }\n    }\n\n    orderHistory = async (orderId) => {\n        try {\n            let trades = await this.requestPrivate(`/mytrades`, { symbol: 'ETHUSD'} )\n            let orderTrades = trades.filter((trade) =>{\n                return trade.order_id == orderId\n            })\n\n            let fee = 0\n            let amount = 0\n            let price = 0\n            let numberOfTrades = 0\n\n            orderTrades.forEach((trade) => {\n                fee = parseFloat(trade.fee_amount) + fee\n                amount = parseFloat(trade.amount) + amount\n                price = parseFloat(trade.price) + price\n                numberOfTrades = numberOfTrades + 1\n            })\n\n            let averagePrice = price / numberOfTrades\n\n            let tradeSummary = {\n                fee,\n                amount,\n                price: averagePrice\n            }\n\n            return tradeSummary\n        } catch(err){\n            this.logger.info(`gemini orderStatus |> ${err}`)\n            return Promise.reject(`gemini orderStatus |> ${err}`)\n        }\n    }\n}"]}